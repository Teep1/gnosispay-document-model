{
  "author": {
    "name": "Claude",
    "website": "https://powerhouse.inc"
  },
  "description": "Track and analyze GnosisPay card transactions with multi-token and forex support",
  "extension": "gpa",
  "id": "gnosispay/analytics",
  "name": "GnosispayAnalytics",
  "specifications": [
    {
      "changeLog": [],
      "modules": [
        {
          "description": "Operations for managing blockchain transactions",
          "id": "transaction-management",
          "name": "Transaction Management",
          "operations": [
            {
              "description": "Add a single transaction manually",
              "errors": [],
              "examples": [],
              "id": "add-transaction",
              "name": "ADD_TRANSACTION",
              "reducer": "const transaction = {\n  id: action.input.id,\n  txHash: action.input.txHash,\n  blockNumber: action.input.blockNumber,\n  timestamp: action.input.timestamp,\n  fromAddress: action.input.fromAddress || null,\n  toAddress: action.input.toAddress || null,\n  contractAddress: action.input.contractAddress || null,\n  valueIn: action.input.valueIn ? {\n    amount: action.input.valueIn.amount,\n    token: action.input.valueIn.token,\n    usdValue: action.input.valueIn.usdValue ?? null\n  } : null,\n  valueOut: action.input.valueOut ? {\n    amount: action.input.valueOut.amount,\n    token: action.input.valueOut.token,\n    usdValue: action.input.valueOut.usdValue ?? null\n  } : null,\n  txnFee: {\n    amount: action.input.txnFee.amount,\n    token: action.input.txnFee.token,\n    usdValue: action.input.txnFee.usdValue ?? null\n  },\n  historicalPrice: action.input.historicalPrice || null,\n  currentValue: action.input.currentValue || null,\n  convertedValue: action.input.convertedValue || null,\n  status: action.input.status,\n  errorCode: action.input.errorCode || null,\n  method: action.input.method || null,\n  transactionType: action.input.transactionType,\n  signedAmount: action.input.signedAmount\n};\n\nstate.transactions.push(transaction);\n\nconst currentTrackedAddress = state.metadata?.trackedAddress || null;\n\nstate.metadata = {\n  importedAt: state.metadata?.importedAt || action.input.timestamp,\n  totalTransactions: state.transactions.length,\n  dateRange: state.metadata?.dateRange || {\n    startDate: action.input.timestamp.split('T')[0],\n    endDate: action.input.timestamp.split('T')[0]\n  },\n  trackedAddress: currentTrackedAddress\n};",
              "schema": "input AddTransactionInput {\n  id: OID!\n  txHash: String!\n  blockNumber: String!\n  timestamp: DateTime!\n  fromAddress: String\n  toAddress: String\n  contractAddress: String\n  valueIn: TokenValueInput\n  valueOut: TokenValueInput\n  txnFee: TokenValueInput!\n  historicalPrice: PriceInfoInput\n  currentValue: PriceInfoInput\n  convertedValue: PriceInfoInput\n  status: TransactionStatusInput!\n  errorCode: String\n  method: String\n  transactionType: TransactionTypeInput!\n  signedAmount: Float!\n}\n\nenum TransactionTypeInput {\n  INCOME\n  EXPENSE\n  NEUTRAL\n}",
              "scope": "global",
              "template": "Add a single transaction manually"
            },
            {
              "description": "Update an existing transaction",
              "errors": [
                {
                  "code": "TRANSACTION_NOT_FOUND",
                  "description": "The specified transaction could not be found",
                  "id": "transaction-not-found-error",
                  "name": "TransactionNotFoundError",
                  "template": "Transaction not found: {id}"
                }
              ],
              "examples": [],
              "id": "update-transaction",
              "name": "UPDATE_TRANSACTION",
              "reducer": "const transactionIndex = state.transactions.findIndex(t => t.id === action.input.id);\nif (transactionIndex === -1) {\n  throw new TransactionNotFoundError(`Transaction with ID ${action.input.id} not found`);\n}\n\nconst transaction = state.transactions[transactionIndex];\nif (action.input.txHash) transaction.txHash = action.input.txHash;\nif (action.input.blockNumber) transaction.blockNumber = action.input.blockNumber;\nif (action.input.timestamp) transaction.timestamp = action.input.timestamp;\nif (action.input.fromAddress !== undefined) transaction.fromAddress = action.input.fromAddress;\nif (action.input.toAddress !== undefined) transaction.toAddress = action.input.toAddress;\nif (action.input.contractAddress !== undefined) transaction.contractAddress = action.input.contractAddress;\nif (action.input.valueIn !== undefined) transaction.valueIn = action.input.valueIn ? {\n  amount: action.input.valueIn.amount,\n  token: action.input.valueIn.token,\n  usdValue: action.input.valueIn.usdValue ?? null\n} : null;\nif (action.input.valueOut !== undefined) transaction.valueOut = action.input.valueOut ? {\n  amount: action.input.valueOut.amount,\n  token: action.input.valueOut.token,\n  usdValue: action.input.valueOut.usdValue ?? null\n} : null;\nif (action.input.txnFee) transaction.txnFee = {\n  amount: action.input.txnFee.amount,\n  token: action.input.txnFee.token,\n  usdValue: action.input.txnFee.usdValue ?? null\n};\nif (action.input.historicalPrice !== undefined) transaction.historicalPrice = action.input.historicalPrice;\nif (action.input.currentValue !== undefined) transaction.currentValue = action.input.currentValue;\nif (action.input.convertedValue !== undefined) transaction.convertedValue = action.input.convertedValue;\nif (action.input.status) transaction.status = action.input.status;\nif (action.input.errorCode !== undefined) transaction.errorCode = action.input.errorCode;\nif (action.input.method !== undefined) transaction.method = action.input.method;\nif (action.input.transactionType) transaction.transactionType = action.input.transactionType;\nif (action.input.signedAmount !== undefined) transaction.signedAmount = action.input.signedAmount;",
              "schema": "input UpdateTransactionInput {\n  id: OID!\n  txHash: String\n  blockNumber: String\n  timestamp: DateTime\n  fromAddress: String\n  toAddress: String\n  contractAddress: String\n  valueIn: TokenValueInput\n  valueOut: TokenValueInput\n  txnFee: TokenValueInput\n  historicalPrice: PriceInfoInput\n  currentValue: PriceInfoInput\n  convertedValue: PriceInfoInput\n  status: TransactionStatusInput\n  errorCode: String\n  method: String\n  transactionType: TransactionTypeInput\n  signedAmount: Float\n}",
              "scope": "global",
              "template": "Update an existing transaction"
            },
            {
              "description": "Delete a transaction by ID",
              "errors": [
                {
                  "code": "DELETE_TRANSACTION_NOT_FOUND",
                  "description": "The specified transaction could not be found for deletion",
                  "id": "delete-tx-not-found-error",
                  "name": "DeleteTransactionNotFoundError",
                  "template": "Transaction not found for deletion: {id}"
                }
              ],
              "examples": [],
              "id": "delete-transaction",
              "name": "DELETE_TRANSACTION",
              "reducer": "const transactionIndex = state.transactions.findIndex(t => t.id === action.input.id);\nif (transactionIndex === -1) {\n  throw new DeleteTransactionNotFoundError(`Transaction with ID ${action.input.id} not found`);\n}\n\nstate.transactions.splice(transactionIndex, 1);\n\nstate.metadata = {\n  importedAt: state.metadata?.importedAt || new Date().toISOString(),\n  totalTransactions: state.transactions.length,\n  dateRange: state.metadata?.dateRange || null,\n  trackedAddress: state.metadata?.trackedAddress || null\n};",
              "schema": "input DeleteTransactionInput {\n  id: OID!\n}",
              "scope": "global",
              "template": "Delete a transaction by ID"
            },
            {
              "description": "Import multiple structured transactions at once. Preferred over CSV import for programmatic imports from APIs like Etherscan.",
              "errors": [
                {
                  "code": "EMPTY_TRANSACTIONS",
                  "description": "The transactions array is empty",
                  "id": "empty-transactions-error",
                  "name": "EmptyTransactionsError",
                  "template": ""
                }
              ],
              "examples": [],
              "id": "import-transactions",
              "name": "IMPORT_TRANSACTIONS",
              "reducer": "if (!action.input.transactions || action.input.transactions.length === 0) {\n  throw new EmptyTransactionsError(\"At least one transaction is required\");\n}\n\nif (!state.transactions) {\n  state.transactions = [];\n}\n\nconst EXCLUDED_CONTRACTS = new Set([\"0x5cb9073902f2035222b9749f8fb0c9bfe5527108\"]);\nconst existingHashes = new Set(state.transactions.map(t => t.txHash));\nconst newTransactions = [];\n\nfor (const input of action.input.transactions) {\n  if (existingHashes.has(input.txHash)) continue;\n  if (input.contractAddress && EXCLUDED_CONTRACTS.has(input.contractAddress.toLowerCase())) continue;\n\n  newTransactions.push({\n    id: input.id,\n    txHash: input.txHash,\n    blockNumber: input.blockNumber,\n    timestamp: input.timestamp,\n    fromAddress: input.fromAddress || null,\n    toAddress: input.toAddress || null,\n    contractAddress: input.contractAddress || null,\n    category: null,\n    valueIn: input.valueIn ? { amount: input.valueIn.amount, token: input.valueIn.token, usdValue: input.valueIn.usdValue ?? null } : null,\n    valueOut: input.valueOut ? { amount: input.valueOut.amount, token: input.valueOut.token, usdValue: input.valueOut.usdValue ?? null } : null,\n    txnFee: { amount: input.txnFee.amount, token: input.txnFee.token, usdValue: input.txnFee.usdValue ?? null },\n    historicalPrice: input.historicalPrice || null,\n    currentValue: input.currentValue || null,\n    convertedValue: input.convertedValue || null,\n    status: input.status,\n    errorCode: input.errorCode || null,\n    method: input.method || null,\n    transactionType: input.transactionType,\n    signedAmount: input.signedAmount\n  });\n  existingHashes.add(input.txHash);\n}\n\nstate.transactions.push(...newTransactions);\n\nif (newTransactions.length > 0) {\n  const timestamps = newTransactions.map(t => new Date(t.timestamp).getTime()).filter(t => !isNaN(t));\n  state.metadata = {\n    importedAt: action.input.timestamp,\n    totalTransactions: state.transactions.length,\n    dateRange: timestamps.length > 0 ? {\n      startDate: new Date(Math.min(...timestamps)).toISOString().split('T')[0],\n      endDate: new Date(Math.max(...timestamps)).toISOString().split('T')[0]\n    } : state.metadata?.dateRange || null,\n    trackedAddress: action.input.trackedAddress\n  };\n} else {\n  state.metadata = {\n    importedAt: action.input.timestamp,\n    totalTransactions: state.transactions.length,\n    dateRange: state.metadata?.dateRange || null,\n    trackedAddress: action.input.trackedAddress\n  };\n}",
              "schema": "input ImportTransactionsInput {\n  transactions: [AddTransactionInput!]!\n  timestamp: DateTime!\n  trackedAddress: String!\n}",
              "scope": "global",
              "template": ""
            }
          ]
        },
        {
          "description": "Operations for managing currencies and exchange rates",
          "id": "currency-management",
          "name": "Currency Management",
          "operations": [
            {
              "description": "Set the base currency for analytics and conversions",
              "errors": [],
              "examples": [],
              "id": "set-base-currency",
              "name": "SET_BASE_CURRENCY",
              "reducer": "state.settings.baseCurrency = action.input.baseCurrency;",
              "schema": "input SetBaseCurrencyInput {\n  baseCurrency: Currency!\n}",
              "scope": "global",
              "template": "Set the base currency for analytics and conversions"
            },
            {
              "description": "Update exchange rates for currency conversions",
              "errors": [],
              "examples": [],
              "id": "update-exchange-rates",
              "name": "UPDATE_EXCHANGE_RATES",
              "reducer": "state.settings.exchangeRates = action.input.rates;\nstate.settings.lastForexUpdate = action.input.timestamp;",
              "schema": "input UpdateExchangeRatesInput {\n  rates: [ExchangeRateInput!]!\n  timestamp: DateTime!\n}\n\ninput ExchangeRateInput {\n  fromCurrency: Currency!\n  toCurrency: Currency!\n  rate: Float!\n  timestamp: DateTime!\n}",
              "scope": "global",
              "template": "Update exchange rates for currency conversions"
            },
            {
              "description": "Convert transaction values to the specified base currency",
              "errors": [],
              "examples": [],
              "id": "convert-transaction-values",
              "name": "CONVERT_TRANSACTION_VALUES",
              "reducer": "const transaction = state.transactions.find(t => t.id === action.input.transactionId);\nif (!transaction) {\n  throw new TransactionNotFoundError(`Transaction with ID ${action.input.transactionId} not found`);\n}\n\nconst findExchangeRate = (fromCurrency: string, toCurrency: string) => {\n  return state.settings.exchangeRates.find(rate => \n    rate.fromCurrency === fromCurrency && rate.toCurrency === toCurrency\n  );\n};\n\nif (transaction.valueIn && transaction.valueIn.token !== action.input.baseCurrency) {\n  const rate = findExchangeRate(transaction.valueIn.token, action.input.baseCurrency);\n  if (rate) {\n    transaction.convertedValue = {\n      amount: transaction.valueIn.amount * rate.rate,\n      currency: action.input.baseCurrency\n    };\n  }\n}\n\nif (transaction.txnFee && action.input.baseCurrency === 'USD') {\n  const rate = findExchangeRate(transaction.txnFee.token, 'USD');\n  if (rate) {\n    transaction.txnFee.usdValue = transaction.txnFee.amount * rate.rate;\n  }\n}\n\nif (transaction.valueIn && action.input.baseCurrency === 'USD') {\n  const rate = findExchangeRate(transaction.valueIn.token, 'USD');\n  if (rate) {\n    transaction.valueIn.usdValue = transaction.valueIn.amount * rate.rate;\n  }\n}\n\nif (transaction.valueOut && action.input.baseCurrency === 'USD') {\n  const rate = findExchangeRate(transaction.valueOut.token, 'USD');\n  if (rate) {\n    transaction.valueOut.usdValue = transaction.valueOut.amount * rate.rate;\n  }\n}",
              "schema": "input ConvertTransactionValuesInput {\n  transactionId: OID!\n  baseCurrency: Currency!\n}",
              "scope": "global",
              "template": "Convert transaction values to the specified base currency"
            }
          ]
        },
        {
          "description": "Operations for calculating transaction analytics",
          "id": "analytics",
          "name": "Analytics",
          "operations": [
            {
              "description": "Calculate spending analytics based on transactions",
              "errors": [],
              "examples": [],
              "id": "calculate-analytics",
              "name": "CALCULATE_ANALYTICS",
              "reducer": "const transactions = state.transactions;\nif (transactions.length === 0) {\n  state.analytics = { totalSpent: null, averageTransaction: null, transactionsByToken: [], monthlyBreakdown: [], spendingByCategory: [] };\n  state.detectedBaseCurrency = null;\n  return;\n}\n\nfunction normalizeToken(token) {\n  if (!token) return \"\";\n  const normalized = token.trim().toUpperCase();\n  if (normalized === \"USDC\" || normalized === \"USD\") return \"USDC\";\n  if (normalized === \"EUR\" || normalized === \"EURE\") return \"EURe\";\n  if (normalized === \"GBP\" || normalized === \"GBPE\") return \"GBPe\";\n  return token.trim();\n}\n\nfunction isGnosisPayStablecoin(token) {\n  const normalized = normalizeToken(token);\n  return normalized === \"USDC\" || normalized === \"EURe\" || normalized === \"GBPe\";\n}\n\nlet totalAmount = 0;\nconst tokenAmounts = {};\nconst monthlyAmounts = {};\n\ntransactions.forEach((tx) => {\n  let amount = 0;\n  if (tx.convertedValue) {\n    amount = tx.convertedValue.amount;\n  } else if (tx.valueOut && tx.valueOut.token === action.input.baseCurrency) {\n    amount = tx.valueOut.amount;\n  } else if (tx.valueOut && tx.valueOut.usdValue && action.input.baseCurrency === \"USD\") {\n    amount = tx.valueOut.usdValue;\n  }\n  if (amount > 0) {\n    totalAmount += amount;\n    const originalToken = tx.valueOut?.token || \"Unknown\";\n    tokenAmounts[originalToken] = (tokenAmounts[originalToken] || 0) + (tx.valueOut?.amount || 0);\n    const month = new Date(tx.timestamp).toISOString().substring(0, 7);\n    monthlyAmounts[month] = (monthlyAmounts[month] || 0) + amount;\n  }\n});\n\nstate.analytics = {\n  totalSpent: totalAmount > 0 ? { amount: totalAmount, token: action.input.baseCurrency, usdValue: action.input.baseCurrency === \"USD\" ? totalAmount : null } : null,\n  averageTransaction: totalAmount > 0 ? { amount: totalAmount / transactions.length, token: action.input.baseCurrency, usdValue: action.input.baseCurrency === \"USD\" ? totalAmount / transactions.length : null } : null,\n  transactionsByToken: Object.entries(tokenAmounts).map(([token, amount]) => ({ amount, token, usdValue: null })),\n  monthlyBreakdown: Object.entries(monthlyAmounts).map(([month, amount]) => ({ amount, token: action.input.baseCurrency, usdValue: action.input.baseCurrency === \"USD\" ? amount : null })),\n  spendingByCategory: []\n};\n\nconst transactionCounts = { USDC: 0, EURe: 0, GBPe: 0 };\nconst totalVolume = { USDC: 0, EURe: 0, GBPe: 0 };\n\ntransactions.forEach((tx) => {\n  if (tx.valueIn?.token && isGnosisPayStablecoin(tx.valueIn.token)) {\n    const normalized = normalizeToken(tx.valueIn.token);\n    if (isGnosisPayStablecoin(normalized)) {\n      transactionCounts[normalized]++;\n      totalVolume[normalized] += tx.valueIn.amount || 0;\n    }\n  }\n  if (tx.valueOut?.token && isGnosisPayStablecoin(tx.valueOut.token)) {\n    const normalized = normalizeToken(tx.valueOut.token);\n    if (isGnosisPayStablecoin(normalized)) {\n      transactionCounts[normalized]++;\n      totalVolume[normalized] += tx.valueOut.amount || 0;\n    }\n  }\n});\n\nconst totalStablecoinTxs = Object.values(transactionCounts).reduce((sum, count) => sum + count, 0);\n\nif (totalStablecoinTxs > 0) {\n  const currencyCodes = { USDC: \"USD\", EURe: \"EUR\", GBPe: \"GBP\" };\n  const volumeEntries = Object.entries(totalVolume).sort((a, b) => b[1] - a[1]);\n  const [topByVolume, topVol] = volumeEntries[0];\n  const secondVol = volumeEntries[1]?.[1] || 0;\n  let detectedStablecoin = topByVolume;\n  let reason;\n  if (topVol === secondVol && secondVol > 0) {\n    const countEntries = Object.entries(transactionCounts).sort((a, b) => b[1] - a[1]);\n    if (countEntries[0][0] !== topByVolume) {\n      detectedStablecoin = countEntries[0][0];\n      reason = \"Selected \" + countEntries[0][0] + \" based on transaction count (\" + countEntries[0][1] + \" transactions) due to volume tie\";\n    } else {\n      reason = \"Selected \" + topByVolume + \" based on volume (\" + topVol.toFixed(2) + \"), confirmed by transaction count\";\n    }\n  } else if (topVol > 0) {\n    const totalVol = volumeEntries.reduce((sum, e) => sum + e[1], 0);\n    reason = \"Selected \" + topByVolume + \" based on \" + topVol.toFixed(2) + \" volume (\" + Math.round((topVol / totalVol) * 100) + \"% of stablecoin volume)\";\n  } else {\n    const countEntries = Object.entries(transactionCounts).sort((a, b) => b[1] - a[1]);\n    detectedStablecoin = countEntries[0][0];\n    reason = \"Selected \" + countEntries[0][0] + \" based on \" + countEntries[0][1] + \" transactions (no volume data)\";\n  }\n  const volumeGap = topVol - secondVol;\n  const confidenceFromVolume = Math.min(volumeGap / Math.max(topVol, 1), 1);\n  const confidence = 0.6 * confidenceFromVolume + 0.4;\n  state.detectedBaseCurrency = { stablecoin: detectedStablecoin, currencyCode: currencyCodes[detectedStablecoin], confidence, transactionCounts, totalVolume, reason };\n} else {\n  state.detectedBaseCurrency = null;\n}",
              "schema": "input CalculateAnalyticsInput {\n  baseCurrency: Currency!\n}",
              "scope": "global",
              "template": "Calculate spending analytics based on transactions"
            }
          ]
        }
      ],
      "state": {
        "global": {
          "examples": [],
          "initialValue": "{\n  \"transactions\": [],\n  \"analytics\": null,\n  \"metadata\": null,\n  \"detectedBaseCurrency\": null,\n  \"settings\": {\n    \"baseCurrency\": \"USD\",\n    \"lastForexUpdate\": null,\n    \"exchangeRates\": []\n  }\n}",
          "schema": "type GnosispayAnalyticsState {\n  transactions: [Transaction!]!\n  analytics: Analytics\n  metadata: TransactionMetadata\n  detectedBaseCurrency: DetectedBaseCurrency\n  settings: Settings!\n}\n\ntype DetectedBaseCurrency {\n  stablecoin: String!\n  currencyCode: String!\n  confidence: Float!\n  transactionCounts: TransactionCounts!\n  totalVolume: VolumeCounts!\n  reason: String!\n}\n\ntype TransactionCounts {\n  USDC: Int!\n  EURe: Int!\n  GBPe: Int!\n}\n\ntype VolumeCounts {\n  USDC: Float!\n  EURe: Float!\n  GBPe: Float!\n}\n\ntype TokenValue {\n  amount: Float!\n  token: String!\n  usdValue: Float\n}\n\ntype PriceInfo {\n  amount: Float!\n  currency: Currency!\n}\n\ntype DateRange {\n  startDate: Date!\n  endDate: Date!\n}\n\ntype TransactionMetadata {\n  importedAt: DateTime!\n  totalTransactions: Int!\n  dateRange: DateRange\n  trackedAddress: String\n}\n\nenum TransactionStatus {\n  SUCCESS\n  FAILED\n}\n\nenum TransactionType {\n  INCOME\n  EXPENSE\n  NEUTRAL\n}\n\ntype Transaction {\n  id: OID!\n  txHash: String!\n  blockNumber: String!\n  timestamp: DateTime!\n  fromAddress: String\n  toAddress: String\n  contractAddress: String\n  category: String\n  valueIn: TokenValue\n  valueOut: TokenValue\n  txnFee: TokenValue!\n  historicalPrice: PriceInfo\n  currentValue: PriceInfo\n  convertedValue: PriceInfo\n  status: TransactionStatus!\n  errorCode: String\n  method: String\n  transactionType: TransactionType!\n  signedAmount: Float!\n}\n\ntype ExchangeRate {\n  fromCurrency: Currency!\n  toCurrency: Currency!\n  rate: Float!\n  timestamp: DateTime!\n}\n\ntype Settings {\n  baseCurrency: Currency!\n  lastForexUpdate: DateTime\n  exchangeRates: [ExchangeRate!]!\n}\n\ntype Analytics {\n  totalSpent: TokenValue\n  averageTransaction: TokenValue\n  transactionsByToken: [TokenValue!]!\n  monthlyBreakdown: [TokenValue!]!\n  spendingByCategory: [CategoryValue!]!\n}\n\ntype CategoryValue {\n  category: String!\n  amount: Float!\n  token: String!\n  usdValue: Float\n}\n\ninput TokenValueInput {\n  amount: Float!\n  token: String!\n  usdValue: Float\n}\n\ninput PriceInfoInput {\n  amount: Float!\n  currency: Currency!\n}\n\nenum TransactionStatusInput {\n  SUCCESS\n  FAILED\n}"
        },
        "local": {
          "examples": [],
          "initialValue": "",
          "schema": ""
        }
      },
      "version": 1
    }
  ]
}